package com.daysun.javase.thread.getset;

/*
 * 线程间的通信：不同种类的线程对共享数据的操作。
 *
 * 通过对学生对象设置或者获取值来演示。
 * A:造了四个类
 * 		Student:资源类
 * 		SetThread:设置线程
 * 		GetThread:获取线程
 * 		StudentTest:测试类
 *
 * B:为了保证操作的资源是同一个，我们在测试类创建了学生对象。
 *   然后把学生对象作为构造参数传递到不同的线程操作类中。
 *
 * C:我们在每个线程里面加入了多次操作。并且在设置的时候，我为了区分数据，给出不同的name和age。
 *   最终有这样的两个小问题
 * 		a:同一个数据出现多次。
 * 			获取到的那一点点CPU的执行权，也够你执行很多次。
 * 		b:数据出现了安全问题。
 * 			刘意 30
 * 			林青霞 27
 * 			刘意 27
 * 			林青霞 30
 *
 * 	  D:既然出问题了，那么我们就应该解决问题。
 * 		怎么就出问题了?
 * 			a:多线程
 * 			b:共享数据
 * 			c:多条语句操作共享数据
 * 		怎么解决呢?
 * 			通过同步解决。
 *
 * 		我们最终选择同步代码快解决。问题是，到底在哪里加这个代码块呢?
 * 			在问题的c步骤加同步即可。
 *
 * 			注意：如果是种类不同的线程，请保证这多个线程的锁必须是同一把。
 * E:正常现象：
 * 		有数据，就等待，等待输出。没有数据，就等待有数据后，再输出。
 *
 * 		等待唤醒机制：
 * 			wait()和notify()组合。
 *
 * 		举例：
 * 			抓人小游戏。
 * 				5个人，石头剪刀布，直到最后一个人：输家。
 * 				4个赢家先跑起来，然后由这个输家来抓。
 * 				赢家在跑不过的时候，可以喊：定，停。wait()
 * 				另一个赢家可以救活定的那个人：醒，走。notify()
 * 				我要是抓到了，但是，他还没喊出来，那么，我就开始跑，他就开始抓人。
 *
 * F:wait()方法的特点：
 * 		哪里等待，从哪里释放锁。将来醒过来的时候，是从上次等待的地方醒过来的。
 *
 * G:面试题：
 * 		sleep()和wait()的区别?
 * 		A:sleep()表示睡眠，必须指定睡眠时间。不释放锁。
 * 		B:wait()表示等待，可以指定时间，也可以不指定时间。释放锁。
 */
public class StudentTest {
    public static void main(String[] args) {
        // 创建一个资源
        Student s = new Student();

        // 设置线程
        SetThread st = new SetThread(s);

        // 获取线程
        GetThread gt = new GetThread(s);

        Thread t1 = new Thread(st);
        Thread t2 = new Thread(gt);

        t1.start();
        t2.start();
    }
}
